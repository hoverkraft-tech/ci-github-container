name: Internal - Common Continuous Integration tasks

on:
  workflow_call:

jobs:
  setup-tests:
    runs-on: ubuntu-latest
    steps:
      - run: |
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GitHub token secrets is not set"
            exit 1
          fi
  tests:
    needs: setup-tests
    uses: ./.github/workflows/docker-build-images.yml
    secrets:
      oci-registry-password: ${{ secrets.GITHUB_TOKEN }}
    with:
      images: |
        [
          {
            "name": "application-1",
            "context": ".",
            "dockerfile": "./tests/application-1/Dockerfile",
            "build-args": { "PROD_MODE": "true" },
            "target": "prod",
            "platforms": ["linux/amd64","linux/arm64","linux/arm/v7"]
          },
          {
            "name": "application-2",
            "context": ".",
            "dockerfile": "./tests/application-2/Dockerfile",
            "build-args": { "PROD_MODE": "true" },
            "target": "prod",
            "platforms": ["linux/amd64","linux/arm64","linux/arm/v7"]
          }
        ]

  checks:
    continue-on-error: true
    needs: tests
    runs-on: "ubuntu-latest"
    steps:
      - name: Check built images ouput
        uses: actions/github-script@v6.4.1
        with:
          script: |
            const assert = require("assert");

            const builtImagesOutput = `${{ needs.tests.outputs.built-images }}`;
            assert(builtImagesOutput.length, `"built-images" output is empty`);

            // Check if is valid Json
            let builtImages = null;
            try {
              builtImages = JSON.parse(builtImagesOutput);
            } catch (error) {
              throw new Error(`"built-images" output is not a valid JSON: ${error}`);
            }

            assert(typeof builtImages === "object" && !Array.isArray(builtImages), `"built-images" output is not an object`);
            assert.equal(Object.keys(builtImages).length, 2, `"built-images" output does not contain 2 images`);

            assert(builtImages["application-1"], `"built-images" output does not contain "application-1" image`);

            const application1Image = builtImages["application-1"];
            assert.equal(application1Image.name, "application-1");
            assert.equal(application1Image.registry, "ghcr.io");
            assert.equal(application1Image.repository,"hoverkraft-tech/ci-github-container/application-1");
            assert(application1Image.tags.length);
            assert(application1Image.images.length);
            application1Image.images.forEach(image => assert.match(image, /^ghcr\.io\/hoverkraft-tech\/ci-github-container\/application-1:[\.a-z0-9-]+$/));

            const application2Image = builtImages["application-2"];
            assert.equal(application2Image.name, "application-2");
            assert.equal(application2Image.registry, "ghcr.io");
            assert.equal(application2Image.repository,"hoverkraft-tech/ci-github-container/application-2");
            assert(application2Image.tags.length);
            assert(application2Image.images.length);
            application2Image.images.forEach(image => assert.match(image, /^ghcr\.io\/hoverkraft-tech\/ci-github-container\/application-2:[\.a-z0-9-]+$/));

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Check docker images
        run: |
          IMAGES=(
            "${{ fromJson(needs.tests.outputs.built-images).application-1.images[0] }}"
            "${{ fromJson(needs.tests.outputs.built-images).application-2.images[0] }}"
          )

          for IMAGE in "${IMAGES[@]}"; do
            echo "Checking image: ${IMAGE}"

            MANIFEST=$(docker manifest inspect "$IMAGE")
            if ! MANIFEST=$(docker manifest inspect "$IMAGE"); then
              echo "Failed to inspect manifest for image: ${IMAGE}"
              echo "${MANIFEST}"
              exit 1
            fi

            PLATFORMS=$(echo "${MANIFEST}" | jq -e '.manifests[].platform')

            # Check if all platforms are present

            ## os=linux,architecture=amd64,variant=null
            PLATFORM=$(echo "${PLATFORMS}" | jq -e '. | select(.architecture == "amd64")')
            echo "${PLATFORM}" | jq -e '.os' | grep -q 'linux'
            echo "${PLATFORM}" | jq -e '.variant' | grep -q 'null'

            ## os=linux,architecture=arm64,variant=null
            PLATFORM=$(echo "${PLATFORMS}" | jq -e '. | select(.architecture == "arm64")')
            echo "${PLATFORM}" | jq -e '.os' | grep -q 'linux'
            echo "${PLATFORM}" | jq -e '.variant' | grep -q 'null'

            ## os=linux,architecture=arm,variant=v7
            PLATFORM=$(echo "${PLATFORMS}" | jq -e '. | select(.architecture == "arm/v7")')
            echo "${PLATFORM}" | jq -e '.os' | grep -q 'linux'
            echo "${PLATFORM}" | jq -e '.variant' | grep -q 'v7'

            docker pull "$IMAGE"
          done

  cleanup:
    needs: checks
    runs-on: "ubuntu-latest"
    permissions:
      packages: write
    steps:
      - uses: actions/checkout@v4

      - id: get-issue-number
        if: ${{ github.event_name == 'pull_request' }}
        uses: hoverkraft-tech/ci-github-common/actions/get-issue-number@0.7.5

      - name: Cleanup application-1 images
        if: ${{ github.event_name == 'pull_request' }}
        uses: ./actions/docker/delete-image-tags
        with:
          image: "application-1"
          tag-prefix: "${{ steps.get-issue-number.outputs.issue-number }}-"

      - name: Cleanup application-2 images
        if: ${{ github.event_name == 'pull_request' }}
        uses: ./actions/docker/delete-image-tags
        with:
          image: "application-2"
          tag-prefix: "${{ steps.get-issue-number.outputs.issue-number }}-"
