# Docker build images
# ==========================
# Workflow to build multiple docker images.
# Build images using [Docker build image](https://github.com/hoverkraft-tech/ci-github-container/blob/main/actions/docker/build-image/README.md)
# This includes [multi-platform](https://docs.docker.com/build/building/multi-platform/) build

name: Docker build images

on:
  workflow_call:
    outputs:
      built-images:
        description: 'Built images names and tags. Example: {
          "application": {
          "name": "application",
          "registry": "ghcr.io",
          "repository": "my-org/my-repo/application",
          "tags": ["pr-63-5222075","pr-63"],
          "images": ["ghcr.io/my-org/my-repo/application:pr-63-5222075","ghcr.io/my-org/my-repo/application:pr-63"],
          }
          }'
        value: ${{ jobs.outputs-built-images.outputs.built-images }}
    inputs:
      runs-on:
        description: "Runner to use. Json array of runners. See https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job"
        type: string
        default: '["ubuntu-latest"]'
        required: false
      oci-registry:
        description: "OCI registry where to pull and push images"
        type: string
        default: "ghcr.io"
        required: false
      oci-registry-username:
        description: "Username used to log against the OCI registry. See https://github.com/docker/login-action#usage"
        type: string
        default: ${{ github.repository_owner }}
        required: false
      images:
        description: 'Images to build parameters. Example: [{
          "name": "application",
          "context": ".",
          "dockerfile": "./docker/application/Dockerfile",
          "build-args": { "APP_PATH": "./application/", "PROD_MODE": "true" },
          "target": "prod",
          "platforms": ["linux/amd64","linux/arm64","linux/arm/v7"]
          }]'
        type: string
        required: true
    secrets:
      oci-registry-password:
        description: "Password or GitHub token (packages:read and packages:write scopes) used to log against the OCI registry. See https://github.com/docker/login-action#usage"
        required: true
      build-secrets:
        description: "List of secrets to expose to the build. See [https://docs.docker.com/build/ci/github-actions/secrets/](https://docs.docker.com/build/ci/github-actions/secrets/)"
        required: false

jobs:
  prepare-variables:
    outputs:
      images: ${{ steps.validate-inputs.outputs.images }}
      artifact-name: ${{ steps.define-artifact-name.outputs.artifact-name }}
    runs-on: ${{ fromJson(inputs.runs-on) }}
    steps:
      - id: validate-inputs
        uses: actions/github-script@v7.0.0
        with:
          script: |
            const ociRegistryPassword = `${{ secrets.oci-registry-password }}`;
            if (!ociRegistryPassword) {
              throw new Error(`"oci-registry-password" secret is missing`);
            }

            const imagesInput = `${{ inputs.images }}`;

            // Check if is valid Json
            let images = null;
            try {
              images = JSON.parse(imagesInput);
            } catch (error) {
              throw new Error(`"images" input is not a valid JSON: ${error}`);
            }

            // Check if is an array
            if (!Array.isArray(images)) {
              throw new Error(`"images" input is not an array`);
            }

            // Check each item
            const imagesByPlatform = [];
            for (const key in images) {
              const image = images[key];
              if (typeof image !== 'object') {
                throw new Error(`"images[${key}]" input is not an object`);
              }

              // Check mandatory properties
              for (const property of ['name', 'platforms']) {
                if (!image.hasOwnProperty(property)) {
                  throw new Error(`"images[${key}].${property}" input is missing`);
                }
              }

              // Format build-args object to string
              if(image['build-args']){
                const buildArgs = Object.keys(image['build-args']).map(key => `${key}=${image['build-args'][key]}`).join('\n');
                image['build-args'] = buildArgs;
              }

              // Add image for each platform
              for (const platform of image['platforms']) {
                const imageByPlatform = {
                  ...image,
                  platform: platform
                };
                imagesByPlatform.push(imageByPlatform);
              }
            }

            core.setOutput('images', JSON.stringify(imagesByPlatform));

      - id: define-artifact-name
        uses: actions/github-script@v7.0.0
        with:
          script: |
            function uniqid(prefix = "") {
                const sec = Date.now() * 1000 + Math.random() * 1000;
                const id = sec.toString(16).replace(/\./g, "").padEnd(14, "0");
                return `${prefix}${id}`;
            };

            core.setOutput('artifact-name', uniqid("build-images-"));

  build-images:
    name: Build image ${{ matrix.image.name }} for ${{ matrix.image.platform }}
    needs: prepare-variables
    runs-on: ${{ fromJson(inputs.runs-on) }}
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.prepare-variables.outputs.images) }}
    permissions:
      contents: read
      pull-requests: read
      issues: read
      packages: write
      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      id-token: write
    steps:
      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        uses: ChristopherHX/oidc@v2
      - uses: actions/checkout@v4
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
      - run: |
          echo "self-workflow" >> .gitignore
          echo "self-workflow" >> .dockerignore

      - id: metadata
        uses: ./self-workflow/actions/docker/get-image-metadata
        with:
          oci-registry: ${{ inputs.oci-registry }}
          tag: ${{ matrix.image.tag }}
          image: ${{ matrix.image.name }}

      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      - uses: actions/checkout@v4
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
      - run: |
          echo "self-workflow" >> .gitignore
          echo "self-workflow" >> .dockerignore

      - id: build
        uses: ./self-workflow/actions/docker/build-image
        with:
          oci-registry: ${{ inputs.oci-registry }}
          oci-registry-username: ${{ inputs.oci-registry-username }}
          oci-registry-password: ${{ secrets.oci-registry-password }}
          image: ${{ steps.metadata.outputs.image }}
          labels: ${{ steps.metadata.outputs.labels }}
          context: ${{ matrix.image.context }}
          dockerfile: ${{ matrix.image.dockerfile }}
          build-args: ${{ matrix.image.build-args }}
          target: ${{ matrix.image.target }}
          platform: ${{ matrix.image.platform }}
          secrets: ${{ secrets.build-secrets }}

      - id: outputs-built-image
        uses: actions/github-script@v7.0.0
        with:
          script: |
            const builtImage = {
              "name": `${{ matrix.image.name }}`,
              "image": `${{ steps.metadata.outputs.image }}`,
              "tags": `${{ steps.metadata.outputs.tags }}`.split("\n").map(tag => tag.trim()).filter(tag => tag !== ""),
              "digest": `${{ steps.build.outputs.digest }}`,
            };
            core.setOutput("built-image", JSON.stringify(builtImage));

      # FIXME: Set built images infos in file to be uploaded as artifacts, because github action does not handle job outputs for matrix
      # https://github.com/orgs/community/discussions/26639
      - uses: hoverkraft-tech/ci-github-common/actions/set-matrix-output@0.10.1
        with:
          artifact-name: ${{ needs.prepare-variables.outputs.artifact-name }}
          value: ${{ steps.outputs-built-image.outputs.built-image }}

      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      - uses: actions/checkout@v4
        if: always() && steps.oidc.outputs.job_workflow_repo_name_and_owner
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}

  publish-manifests:
    needs: [prepare-variables, build-images]
    runs-on: ${{ fromJson(inputs.runs-on) }}
    outputs:
      built-images: ${{ steps.get-built-images.outputs.built-images }}
    permissions:
      contents: read
      packages: write
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    steps:
      - id: get-matrix-outputs
        uses: hoverkraft-tech/ci-github-common/actions/get-matrix-outputs@0.10.1
        with:
          artifact-name: ${{ needs.prepare-variables.outputs.artifact-name }}

      - id: get-built-images
        uses: actions/github-script@v7.0.0
        with:
          script: |
            const builtImagesInput = `${{ steps.get-matrix-outputs.outputs.result }}`;
            let builtImages = null;
            try {
              builtImages = JSON.parse(builtImagesInput);
            } catch (error) {
              throw new Error(`"built-images" input is not a valid JSON: ${error}`);
            }

            // Group by image name
            const images = {};
            builtImages.forEach(builtImage => {
              const { name, image, digest, tags } = builtImage;
              if (!images[name]) {
                images[name] = {
                  name,
                  image,
                  digests: [],
                  tags,
                };
              }

              if(images[name].image !== image) {
                throw new Error(`Image mismatch for "${name}"`);
              }

              images[name].digests.push(digest);
            });

            core.setOutput('built-images', JSON.stringify(images));

      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        uses: ChristopherHX/oidc@v2
      - uses: actions/checkout@v4 # checks out called workflow
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
      - name: ignore self-worfklow changes
        run: |
          echo "self-workflow" >> .gitignore
          echo "self-workflow" >> .dockerignore

      - id: create-images-manifests
        uses: ./self-workflow/actions/docker/create-images-manifests
        with:
          oci-registry: ${{ inputs.oci-registry }}
          oci-registry-username: ${{ inputs.oci-registry-username }}
          oci-registry-password: ${{ secrets.oci-registry-password }}
          built-images: ${{ steps.get-built-images.outputs.built-images }}

  outputs-built-images:
    needs: [publish-manifests]
    runs-on: ${{ fromJson(inputs.runs-on) }}
    outputs:
      built-images: ${{ steps.outputs-built-images.outputs.built-images }}
    steps:
      - id: outputs-built-images
        uses: actions/github-script@v7.0.0
        with:
          script: |
            const builtImagesOutput = `${{ needs.publish-manifests.outputs.built-images }}`;
            let builtImages = null;
            try {
              builtImages = JSON.parse(builtImagesOutput);
            } catch (error) {
              throw new Error(`"built-images" output is not a valid JSON: ${error}`);
            }

            Object.keys(builtImages).forEach(key => {
              const builtImage = builtImages[key];

              const registry = builtImage.image.replace(/([^\/]+)\/[^:]+/,'$1');
              const repository = builtImage.image.replace(/[^\/]+\/([^:]+)/,'$1');
              const images = [...builtImage.tags];
              const tags = builtImage.tags.map(tag => tag.replace(/[^\/]+\/[^:]+:(.+)/,'$1'));

              builtImages[key] = {
                "name": builtImage.name,
                registry,
                repository,
                tags,
                images,
              };
            });

            core.setOutput("built-images", builtImages);
