# Docker build images
# ==========================
# Workflow to build multiple docker images.
# Build images using [Docker build image](https://github.com/hoverkraft-tech/ci-github-container/blob/main/actions/docker/build-image/README.md)
# This includes [multi-platform](https://docs.docker.com/build/building/multi-platform/) build

name: Docker build images

on:
  workflow_call:
    outputs:
      built-images:
        description: 'Built images data. Example: {
          "application": {
          "name": "application",
          "registry": "ghcr.io",
          "repository": "my-org/my-repo/application",
          "tags": ["pr-63-5222075","pr-63"],
          "images": [
          "ghcr.io/my-org/my-repo/application:pr-63-5222075",
          "ghcr.io/my-org/my-repo/application:pr-63"
          ],
          "digests": [
          "ghcr.io/my-org/my-repo/application@sha256:d31aa93410434ac9dcfc9179cac2cb1fd4d7c27f11527addc40299c7c675f49d"
          ],
          "annotations": {
          "org.opencontainers.image.created": "2021-09-30T14:00:00Z",
          "org.opencontainers.image.description": "Application image"
          }
          }
          }'
        value: ${{ jobs.publish-manifests.outputs.built-images }}
    inputs:
      runs-on:
        description: "Runner to use. Json array of runners. See https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job"
        type: string
        default: '["ubuntu-latest"]'
        required: false
      oci-registry:
        description: "OCI registry where to pull and push images"
        type: string
        default: "ghcr.io"
        required: false
      oci-registry-username:
        description: "Username used to log against the OCI registry. See https://github.com/docker/login-action#usage"
        type: string
        default: ${{ github.repository_owner }}
        required: false
      images:
        description: 'Images to build parameters. Example: [{
          "name": "application",
          "context": ".",
          "dockerfile": "./docker/application/Dockerfile",
          "build-args": { "APP_PATH": "./application/", "PROD_MODE": "true" },
          "target": "prod",
          "platforms": [
          "linux/amd64",
          {
          "name": "darwin/amd64",
          "runs-on": "macos-latest"
          }
          ]
          }]'
        type: string
        required: true
    secrets:
      oci-registry-password:
        description: "Password or GitHub token (packages:read and packages:write scopes) used to log against the OCI registry. See https://github.com/docker/login-action#usage"
        required: true
      build-secrets:
        description: "List of secrets to expose to the build. See [https://docs.docker.com/build/ci/github-actions/secrets/](https://docs.docker.com/build/ci/github-actions/secrets/)"
        required: false

jobs:
  prepare-variables:
    outputs:
      images: ${{ steps.validate-inputs.outputs.images }}
      artifact-name: ${{ steps.define-artifact-name.outputs.artifact-name }}
    runs-on: ${{ fromJson(inputs.runs-on) }}
    steps:
      - id: validate-inputs
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const ociRegistryPassword = `${{ secrets.oci-registry-password }}`;
            if (!ociRegistryPassword) {
              throw new Error(`"oci-registry-password" secret is missing`);
            }

            const runsOnInput = `${{ inputs.runs-on }}`;
            let runsOn = null;
            try {
              runsOn = JSON.parse(runsOnInput);
            } catch (error) {
              throw new Error(`"runs-on" input is not a valid JSON: ${error}`);
            }

            const imagesInput = `${{ inputs.images }}`;

            // Check if is valid Json
            let images = null;
            try {
              images = JSON.parse(imagesInput);
            } catch (error) {
              throw new Error(`"images" input is not a valid JSON: ${error}`);
            }

            // Check if is an array
            if (!Array.isArray(images)) {
              throw new Error(`"images" input is not an array`);
            }

            // Check each item
            const imagesByPlatform = [];
            for (const key in images) {
              const image = images[key];
              if (typeof image !== 'object') {
                throw new Error(`"images[${key}]" input is not an object`);
              }

              // Check mandatory properties
              for (const property of ['name', 'platforms']) {
                if (!image.hasOwnProperty(property)) {
                  throw new Error(`"images[${key}].${property}" input is missing`);
                }
              }

              // Format build-args object to string
              if (image['build-args']) {
                const buildArgs = Object.keys(image['build-args']).map(key => `${key}=${image['build-args'][key]}`).join('\n');
                image['build-args'] = buildArgs;
              }

              // Add image for each platform
              const platforms = image['platforms'];
              for (const platform of platforms) {
                let platformName = platform;
                let platformRunsOn = runsOn;

                // Platform can be a string or an object
                if (typeof platform === 'object') {
                  if (!platform.hasOwnProperty('name')) {
                    throw new Error(`"images[${key}].platforms[${platform}].name" input is missing`);
                  }
                  platformName = platform['name'];

                  if (platform.hasOwnProperty('runs-on')) {
                    platformRunsOn = platform['runs-on'];
                  }
                } else if (typeof platform !== 'string') {
                  throw new Error(`"images[${key}].platforms[${platform}]" input is not a string or an object`);
                }

                const imageByPlatform = {
                  ...image,
                  platform: platformName,
                  "runs-on": platformRunsOn,
                };
                imagesByPlatform.push(imageByPlatform);
              }
            }

            core.setOutput('images', JSON.stringify(imagesByPlatform));

      - id: define-artifact-name
        uses: actions/github-script@v7.0.1
        with:
          script: |
            function uniqid(prefix = "") {
                const sec = Date.now() * 1000 + Math.random() * 1000;
                const id = sec.toString(16).replace(/\./g, "").padEnd(14, "0");
                return `${prefix}${id}`;
            };

            core.setOutput('artifact-name', uniqid("build-images-"));

  build-images:
    name: Build image ${{ matrix.image.name }} for ${{ matrix.image.platform }}
    needs: prepare-variables
    runs-on: ${{ matrix.image.runs-on }}
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.prepare-variables.outputs.images) }}
    permissions:
      contents: read
      pull-requests: read
      issues: read
      packages: write
      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      id-token: write
    steps:
      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        uses: ChristopherHX/oidc@v2
      - uses: actions/checkout@v4
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
      - uses: actions/checkout@v4
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
      - run: |
          echo "self-workflow" >> .gitignore
          echo "self-workflow" >> .dockerignore

      - id: build
        uses: ./self-workflow/actions/docker/build-image
        with:
          oci-registry: ${{ inputs.oci-registry }}
          oci-registry-username: ${{ inputs.oci-registry-username }}
          oci-registry-password: ${{ secrets.oci-registry-password }}
          image: ${{ matrix.image.name }}
          context: ${{ matrix.image.context }}
          dockerfile: ${{ matrix.image.dockerfile }}
          build-args: ${{ matrix.image.build-args }}
          target: ${{ matrix.image.target }}
          platform: ${{ matrix.image.platform }}
          secrets: ${{ secrets.build-secrets }}

      # FIXME: Set built images infos in file to be uploaded as artifacts, because github action does not handle job outputs for matrix
      # https://github.com/orgs/community/discussions/26639
      - uses: hoverkraft-tech/ci-github-common/actions/set-matrix-output@0.11.2
        with:
          artifact-name: ${{ needs.prepare-variables.outputs.artifact-name }}
          value: ${{ steps.build.outputs.built-image }}

      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      - uses: actions/checkout@v4
        if: always() && steps.oidc.outputs.job_workflow_repo_name_and_owner
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}

  publish-manifests:
    name: Publish images manifests
    permissions:
      contents: read
      packages: write
      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      id-token: write
    needs: [prepare-variables, build-images]
    runs-on: ${{ fromJson(inputs.runs-on) }}
    outputs:
      built-images: ${{ steps.built-images.outputs.built-images }}
    steps:
      - id: get-matrix-outputs
        uses: hoverkraft-tech/ci-github-common/actions/get-matrix-outputs@0.11.2
        with:
          artifact-name: ${{ needs.prepare-variables.outputs.artifact-name }}

      - id: built-images
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const builtImagesInput = `${{ steps.get-matrix-outputs.outputs.result }}`;
            let builtImages = null;
            try {
              builtImages = JSON.parse(builtImagesInput);
            } catch (error) {
              throw new Error(`"built-images" input is not a valid JSON: ${error}`);
            }

            // Group by image name
            const images = {};
            builtImages.forEach(builtImage => {
              const { name, digests, ...image } = builtImage;
              if (!images[name]) {
                images[name] = {
                  name,
                  digests,
                  ...image,
                };
              } else {
                images[name].digests = [...new Set([...images[name].digests, ...digests])];
              }
            });

            core.setOutput('built-images', JSON.stringify(images));

      # FIXME: This is a workaround for having workflow ref. See https://github.com/orgs/community/discussions/38659
      - id: oidc
        uses: ChristopherHX/oidc@v2
      - uses: actions/checkout@v4 # checks out called workflow
        with:
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
      - name: ignore self-worfklow changes
        run: |
          echo "self-workflow" >> .gitignore
          echo "self-workflow" >> .dockerignore

      - id: create-images-manifests
        uses: ./self-workflow/actions/docker/create-images-manifests
        with:
          oci-registry: ${{ inputs.oci-registry }}
          oci-registry-username: ${{ inputs.oci-registry-username }}
          oci-registry-password: ${{ secrets.oci-registry-password }}
          built-images: ${{ steps.built-images.outputs.built-images }}
