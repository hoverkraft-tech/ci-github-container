---
name: "Docker - Build image"
description: |
  Action to build and push a "raw" image with Docker for a specific platform.
  This action uses the Docker Buildx plugin to build the image.
  It supports caching.
  It returns the image digest URI, tags, and annotations, but does not handle it itself.
author: hoverkraft
branding:
  icon: package
  color: blue

inputs:
  oci-registry:
    description: "OCI registry where to pull and push images"
    default: "ghcr.io"
    required: true
  oci-registry-username:
    description: |
      Username used to log against the OCI registry.
      See https://github.com/docker/login-action#usage.
    default: ${{ github.repository_owner }}
    required: true
  oci-registry-password:
    description: |
      Password or personal access token used to log against the OCI registry.
      Can be passed in using `secrets.GITHUB_TOKEN`.
      See https://github.com/docker/login-action#usage.
    default: ${{ github.token }}
    required: true
  repository:
    description: |
      Repository name.
      Example: `my-org/my-repo`.
      See [Docker get-image-metadata action](../get-image-metadata/README.md).
    default: ${{ github.repository }}
    required: false
  image:
    description: |
      Additional image name.
      Example: `application`.
      See [Docker get-image-metadata action](../get-image-metadata/README.md).
    required: false
  tag:
    description: "Force image tag to publish"
    required: false
  platform:
    description: |
      Platform to build for. Example: `linux/amd64`.
      See https://github.com/docker/build-push-action#inputs.
    required: true
  context:
    description: |
      Build's context is the set of files located in the specified PATH or URL.
      See https://github.com/docker/build-push-action#inputs.
    default: "."
    required: false
  dockerfile:
    description: |
      Location of Dockerfile (defaults to Dockerfile).
      See https://github.com/docker/build-push-action#inputs.
    default: "Dockerfile"
    required: false
  build-args:
    description: |
      List of build-time variables.
      See https://github.com/docker/build-push-action#inputs.
    required: false
  target:
    description: |
      Sets the target stage to build.
      See https://github.com/docker/build-push-action#inputs.
    required: false
  secrets:
    description: |
      List of secrets to expose to the build.
      See https://docs.docker.com/build/ci/github-actions/secrets/.
    required: false
  secret-envs:
    description: |
      List of secret environment variables to expose to the build (e.g., `key=envname, MY_SECRET=MY_ENV_VAR`).
      See https://docs.docker.com/build/ci/github-actions/secrets/.
    required: false
  cache-type:
    description: |
      Cache type.
      See https://docs.docker.com/build/cache/backends.
    default: "gha"
    required: false
  cache-registry:
    description: |
      Optional separate registry for Docker build cache.
      Use this when cache is stored on a different registry than the final image.
      If not set, cache operations use the main oci-registry.
    required: false
  cache-registry-username:
    description: |
      Username for the cache registry.
      Required if cache-registry is set and requires authentication.
    required: false
  cache-registry-password:
    description: |
      Password for the cache registry.
      Required if cache-registry is set and requires authentication.
    required: false
  buildkitd-config-inline:
    description: |
      Inline BuildKit daemon configuration.
      See https://github.com/docker/setup-buildx-action#inputs.
      Example for insecure registry:
        [registry."my-registry.local:5000"]
          http = true
          insecure = true
    required: false
  multi-platform:
    description: |
      Whether this build participates in a multi-platform image publication.
      When true, the image is pushed by digest only so manifests can be assembled later.
      When false, the image is pushed with its tags directly.
    default: false
    required: false

outputs:
  built-image:
    description: |
      Built image data.
      Example:
      ```json
      {
        "name": "application",
        "registry": "ghcr.io",
        "repository": "my-org/my-repo/application",
        "digest": "sha256:d31aa93410434ac9dcfc9179cac2cb1fd4d7c27f11527addc40299c7c675f49d",
        "image": "ghcr.io/my-org/my-repo/application@sha256:d31aa93410434ac9dcfc9179cac2cb1fd4d7c27f11527addc40299c7c675f49d",
        "tags": [
          "pr-63-5222075",
          "pr-63"
        ],
        "annotations": {
          "org.opencontainers.image.created": "2021-09-30T14:00:00Z",
          "org.opencontainers.image.description": "Application image"
        },
        "platform": "linux/amd64",
        "multi-platform": false
      }
      ```
    value: ${{ steps.get-built-image.outputs.built-image }}

runs:
  using: "composite"
  steps:
    - shell: bash
      # FIXME: workaround until will be merged: https://github.com/actions/runner/pull/1684
      run: mkdir -p ./self-actions/ && cp -r $GITHUB_ACTION_PATH/../../* ./self-actions/

    - id: metadata
      uses: ./self-actions/docker/get-image-metadata
      with:
        oci-registry: ${{ inputs.oci-registry }}
        repository: ${{ inputs.repository }}
        image: ${{ inputs.image }}
        tag: ${{ inputs.tag }}

    - shell: bash
      # FIXME: workaround until will be merged: https://github.com/actions/runner/pull/1684
      run: |
        rm -fr ./self-actions

    - id: slugify-platform
      uses: hoverkraft-tech/ci-github-common/actions/slugify@b17226e57c8ef31f860719766656ebb6df017218 # 0.31.6
      with:
        value: ${{ inputs.platform }}

    - id: get-docker-config
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
          const rawContext = `${{ inputs.context }}`.trim();
          const contextPath = rawContext.length > 0 ? rawContext : '.';
          const rawDockerfile = `${{ inputs.dockerfile }}`.trim();
          const dockerfileName = rawDockerfile.length > 0 ? rawDockerfile : 'Dockerfile';

          const dockerfilePath = path.resolve(workspace, contextPath, dockerfileName);

          if (!fs.existsSync(dockerfilePath) || !fs.statSync(dockerfilePath).isFile()) {
            return core.setFailed(`Dockerfile not found at path: ${dockerfilePath}`);
          }

          const resolvedDockerfilePath = fs.realpathSync(dockerfilePath);
          core.setOutput('dockerfile-path', resolvedDockerfilePath);

          const slugifiedPlatform = `${{ steps.slugify-platform.outputs.result }}`;
          const tagSuffix = `-${slugifiedPlatform}`;
          core.setOutput('cache-flavor', `suffix=${tagSuffix}`);

          const cacheType = `${{ inputs.cache-type }}`.trim();
          const metadataImage = `${{ steps.metadata.outputs.image }}`;
          const cacheRegistry = `${{ inputs.cache-registry }}`.trim();

          let cacheImage;
          if (cacheRegistry) {
            // Use separate cache registry: replace the registry part of the image
            const imageParts = metadataImage.split('/');
            // Remove the original registry (first part) and join with cache registry
            imageParts.shift();
            cacheImage = `${cacheRegistry}/${imageParts.join('/')}/cache`;
          } else {
            // Use main registry for cache
            cacheImage = cacheType === 'registry' ? `${metadataImage}/cache` : metadataImage;
          }
          core.setOutput('cache-image', cacheImage);

          try {
            await exec.exec('which', ['docker'], { silent: true });
            core.setOutput('docker-exists', 'true');
          } catch (error) {
            // docker not available on runner
          }

          const multiplatformInput = `${{ inputs.multi-platform }}`.trim().toLowerCase();
          const isMultiplatform = !(multiplatformInput.length === 0 || multiplatformInput === 'false');
          if (isMultiplatform) {
            core.debug('Multi-platform build is enabled.');
            core.setOutput('multi-platform', true);
          }

          const platform = `${{ inputs.platform }}`.trim();
          if (platform.length === 0) {
            return core.setFailed('Input "platform" is required.');
          }
          const [platformOs, ...platformArchParts] = platform.split('/');
          const { stdout: runnerOsOutput } = await exec.getExecOutput('uname -s');
          const runnerOs = runnerOsOutput.trim().toLowerCase();

          core.debug(`Platform OS: ${platformOs}`);
          core.debug(`Runner OS: ${runnerOs}`);

          if (platformOs.toLowerCase() === runnerOs) {
            const platformArch = platformArchParts.join('/');

            const { stdout: runnerArchOutput } = await exec.getExecOutput('uname -m');
            const runnerArch = runnerArchOutput.trim();

            core.debug(`Platform arch: ${platformArch}`);
            core.debug(`Runner arch: ${runnerArch}`);

            let runnerArchNormalized = runnerArch;
            switch (runnerArch) {
              case 'x86_64':
                runnerArchNormalized = 'amd64';
                break;
              case 'aarch64':
                runnerArchNormalized = 'arm64';
                break;
              case 'armv7l':
                runnerArchNormalized = 'arm/v7';
                break;
              default:
                core.warning(`Unsupported architecture: ${runnerArchRaw}`);
                break;
            }

            if (platformArch === runnerArchNormalized) {
              core.setOutput('platform-exists', 'true');
            }
          }

    - if: steps.get-docker-config.outputs.docker-exists != 'true'
      uses: docker/setup-docker-action@e43656e248c0bd0647d3f5c195d116aacf6fcaf4 # v4.7.0

    - if: steps.get-docker-config.outputs.platform-exists != 'true'
      uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3.7.0
      with:
        platforms: ${{ inputs.platform }}

    - uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      id: setup-buildx
      with:
        # FIXME: upgrade version when available (https://github.com/docker/buildx/releases)
        version: v0.30.1
        # FIXME: upgrade version when available (https://hub.docker.com/r/moby/buildkit)
        driver-opts: |
          image=moby/buildkit:v0.26.2
        buildkitd-config-inline: ${{ inputs.buildkitd-config-inline }}

    # Caching setup
    - id: cache-arguments
      uses: int128/docker-build-cache-config-action@113b5dc2a397fc088bfbddc8ffb44ea9f2565a99 # v1.42.0
      with:
        image: ${{ steps.get-docker-config.outputs.cache-image }}
        flavor: ${{ steps.get-docker-config.outputs.cache-flavor }}
        pull-request-cache: true
        cache-type: ${{ inputs.cache-type }}
        extra-cache-to: "image-manifest=true,oci-mediatypes=true"

    - uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      id: cache
      with:
        path: cache-mount
        key: cache-mount-${{ hashFiles(steps.get-docker-config.outputs.dockerfile-path) }}

    - name: Restore Docker cache mounts
      uses: reproducible-containers/buildkit-cache-dance@5b81f4d29dc8397a7d341dba3aeecc7ec54d6361 # v3.3.0
      with:
        builder: ${{ steps.setup-buildx.outputs.name }}
        cache-dir: cache-mount
        dockerfile: ${{ steps.get-docker-config.outputs.dockerfile-path }}
        skip-extraction: ${{ steps.cache.outputs.cache-hit }}

    - uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
      with:
        registry: ${{ inputs.oci-registry }}
        username: ${{ inputs.oci-registry-username }}
        password: ${{ inputs.oci-registry-password }}

    - uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
      if: inputs.cache-registry
      with:
        registry: ${{ inputs.cache-registry }}
        username: ${{ inputs.cache-registry-username }}
        password: ${{ inputs.cache-registry-password }}
    # jscpd:ignore-end

    - id: build
      uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
      with:
        context: ${{ inputs.context }}
        build-args: ${{ inputs.build-args }}
        target: ${{ inputs.target }}
        file: ${{ steps.get-docker-config.outputs.dockerfile-path }}
        secrets: ${{ inputs.secrets }}
        secret-envs: ${{ inputs.secret-envs }}
        platforms: ${{ inputs.platform }}
        cache-from: ${{ steps.cache-arguments.outputs.cache-from }}
        cache-to: ${{ steps.cache-arguments.outputs.cache-to }}
        outputs: |
          ${{ steps.get-docker-config.outputs.multi-platform && 'type=image,push-by-digest=true,name-canonical=true,push=true' || 'type=image,push=true' }}
        labels: ${{ steps.metadata.outputs.labels }}
        annotations: ${{ steps.metadata.outputs.annotations }}
        tags: ${{ steps.get-docker-config.outputs.multi-platform && steps.metadata.outputs.image || steps.metadata.outputs.tags }}
        provenance: false # Disable provenance to avoid unknown/unknown arch
        sbom: false # Disable sbom to avoid unknown/unknown arch

    - id: get-built-image
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      with:
        script: |
          const builtMetadata = ${{ steps.build.outputs.metadata }};
          if (typeof builtMetadata !== 'object') {
            core.setFailed('Given "metadata" output is not a JSON object.');
            return;
          }

          const name = `${{ inputs.image }}`;
          const image = `${{ steps.metadata.outputs.image }}`;
          const registryMatch = image.match(/^([^\/]+)\/.*/);
          const registry = registryMatch ? registryMatch[1] : null;
          const repositoryMatch = image.match(/^[^\/]+\/([^:]+)/);
          const repository = repositoryMatch ? repositoryMatch[1] : null;

          const tags = `${{ steps.metadata.outputs.tags }}`
          .split("\n")
          .map(tag => tag.replace(/[^\/]+\/[^:]+:(.+)/,'$1').trim())
          .filter(tag => tag !== "");

          let platform;

          const buildxProvenance = builtMetadata?.["buildx.build.provenance"];
          if (buildxProvenance !== undefined) {
            platform = buildxProvenance.invocation?.environment?.platform;
            if (platform === undefined) {
              return core.setFailed('Given "metadata"."buildx.build.provenance"."invocation"."environment"."platform" output is undefined.');
            }
            if (typeof platform !== "string") {
              return core.setFailed('Given "metadata"."buildx.build.provenance"."invocation"."environment"."platform" is not a string.');
            }
            platform = platform.trim();
            if (platform === "") {
              return core.setFailed('Given "metadata"."buildx.build.provenance"."invocation"."environment"."platform" is empty.');
            }
          } else {
            const descriptor = builtMetadata?.["containerimage.descriptor"];
            if (descriptor?.["platform"] === undefined) {
              return core.setFailed('Given "metadata"."containerimage.descriptor"."platform" output is undefined.');
            }
            const platformData = descriptor["platform"];
            if (typeof platformData !== 'object' || platformData.os === undefined || platformData.architecture === undefined) {
              return core.setFailed('Given "metadata"."containerimage.descriptor"."platform" does not contain required "os" and "architecture" fields.');
            }
            platform = `${platformData.os}/${platformData.architecture}${platformData.variant ? `/${platformData.variant}` : ''}`;
          }

          if (builtMetadata?.["containerimage.digest"] === undefined) {
            return core.setFailed('Given "metadata"."containerimage.digest" output is undefined.');
          }

          const digests = builtMetadata["containerimage.digest"]
            .split(",")
            .map(digest => {
              const cleanedDigest = digest.trim();
              return cleanedDigest !== "" ? cleanedDigest : null;
            })
            .filter(digest => digest !== null);

          const uniqueDigests = [...new Set(digests)];
          if (uniqueDigests.length === 0) {
            return core.setFailed('No valid digests found in "containerimage.digest" output.');
          }

          if( uniqueDigests.length > 1 ) {
            return core.setFailed(`Multiple digests found: ${uniqueDigests.join(", ")}.`);
          }

          const digest = uniqueDigests[0];
          const imageWithDigest = `${image}@${digest}`;

          const annotations = `${{ steps.metadata.outputs.annotations }}`
            .split("\n")
            .map(annotation => {
              const cleanedAnnotation = annotation
                .replace(/^[^:]+:/, "")
                .trim();
              return cleanedAnnotation !== "" ? cleanedAnnotation : null;
            })
            .filter(annotation => annotation !== null)
            .reduce((annotations, annotation) => {
              const [key, value] = annotation.split("=");
              annotations[key] = value;
              return annotations;
            }, {})

          const isMultiplatform = Boolean(`${{ steps.get-docker-config.outputs.multi-platform }}`);

          const builtImage = {
            name,
            tags,
            annotations,
            registry,
            repository,
            image: imageWithDigest,
            digest,
            platform,
            "multi-platform": isMultiplatform,
          };

          core.setOutput("built-image", JSON.stringify(builtImage));
