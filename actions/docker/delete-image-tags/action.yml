name: "Delete GitHub registry image tags"
description: "Action to delete docker image tags from GitHub OCI registry"
branding:
  icon: delete
  color: gray-dark

outputs:
  deleted-image-tags:
    description: 'The list of deleted tags for given image. Example: ["1.0.0", "1.0.1"]'
    value: ${{ steps.delete-image-tags.outputs.deleted-image-tags }}

inputs:
  image:
    description: "Image name"
    required: false
  tag-prefix:
    description: "Tag prefix to delete"
    required: false
  github-token:
    description: "GitHub token with the packages:read and packages:delete scopes. See [https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages#about-scopes-and-permissions-for-package-registries](https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages#about-scopes-and-permissions-for-package-registries)"
    default: ${{ github.token }}

runs:
  using: "composite"
  steps:
    - shell: bash
      # FIXME: workaround until will be merged: https://github.com/actions/runner/pull/1684
      run: mkdir -p ./self-actions/ && cp -r $GITHUB_ACTION_PATH/../../* ./self-actions/

    - id: image-name
      uses: ./self-actions/docker/get-image-name
      with:
        image: ${{ inputs.image }}

    - shell: bash
      # FIXME: workaround until will be merged: https://github.com/actions/runner/pull/1684
      run: |
        rm -fr ./self-actions

    - id: delete-image-tags
      uses: actions/github-script@v7.0.1
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const packageName = `${{ steps.image-name.outputs.image-name }}`.replace(`${context.repo.owner}/`, '');
          const tagPrefix = `${{ inputs.tag-prefix }}`;
          const tagPrefixMatcher = tagPrefix ? new RegExp(`^${tagPrefix}(-|$)`) : null;

          const packagePayload = {
            package_type: 'container',
            package_name: packageName,
            org: context.repo.owner,
          };
          core.debug('Package payload: ' + JSON.stringify(packagePayload));

          const packageVersions = await github.paginate(
            github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg.endpoint.merge(packagePayload)
          );
          core.debug('Package versions: ' + JSON.stringify(packageVersions));

          let packageTagsToDelete = [];
          for(const packageVersion of packageVersions) {
            const { metadata } = packageVersion;

            if (!metadata.container.tags.length) {
              continue;
            }

            if(tagPrefixMatcher) {
              packageTagsToDelete.push(...metadata.container.tags.filter(tag => tag.match(tagPrefixMatcher)));
            } else {
              packageTagsToDelete.push(...metadata.container.tags);
            }
          }

          packageTagsToDelete = [...new Set(packageTagsToDelete)];

          core.debug('Package tags to be deleted: ' + JSON.stringify(packageTagsToDelete));

          const deleteImageTags = await Promise.all(
            packageTagsToDelete.map(
              async tag => {
                try{
                  await github.request(
                    "DELETE /orgs/{org}/packages/{package_type}/{package_name}/{tag}", 
                    {...packagePayload, tag}
                  );
                  return tag;
                } catch(error){
                  if (error.status === 404) {
                    core.warning(`Tag ${tag} not found`);
                  } else {
                    throw error;
                  }
                }
              }
            )
          );

          core.setOutput('deleted-image-tags',JSON.stringify(deleteImageTags));
