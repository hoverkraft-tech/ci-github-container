---
name: "Docker - Sign images"
description: |
  Action to sign OCI images.
  It is based on [cosign](https://github.com/sigstore/cosign).
  It signs the images with the GitHub Actions OIDC token.
  If the provided image does not have a digest, it will retrieve the digest using `docker buildx imagetools inspect`.

author: hoverkraft
branding:
  icon: award
  color: blue

inputs:
  images:
    description: |
      Images to sign.
      Can be a single image or a list of images separated by commas or newlines or spaces.
      The images should be in the format `registry/name:tag@digest`.
      It can also be a list of images in JSON format.
      Example:

      ```json
      [
        "ghcr.io/my-org/my-repo/application:pr-63-5222075@sha256:d31aa93410434ac9dcfc9179cac2cb1fd4d7c27f11527addc40299c7c675f49d",
        "ghcr.io/my-org/my-repo/application:pr-63@sha256:0f5aa93410434ac9dcfc9179cac2cb1fd4d7c27f11527addc40299c7c675f402"
      ]
      ```

      If the image does not have a digest, it will retrieve the digest using `docker buildx imagetools inspect`.
    required: true
  github-token:
    description: |
      GitHub Token to sign the image.
      Permissions:
      - `id-token`: `write`
    default: ${{ github.token }}

runs:
  using: "composite"
  steps:
    - uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

    - name: Sign the images with GitHub OIDC Token
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      env:
        COSIGN_EXPERIMENTAL: "1"
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const imagesInput = ${{ toJson(inputs.images) }};
          let images = null;
          try {
            // Try to parse the input as JSON
            images = JSON.parse(imagesInput);
          } catch (error) {
            // If it fails, split the input by commas, newlines or spaces
            images = imagesInput.split(/[\s,]+/).filter(image => image.trim() !== "");
          }

          if (!Array.isArray(images) || images.length === 0) {
            return core.setFailed(`"images" input is not a valid JSON array or a non-empty string: ${images}`);
          }

          // Ensure images are in the correct format
          const registryPart = String.raw`(?<registry>[a-zA-Z0-9._-]+(?:\.[a-zA-Z0-9._-]+)*(?::[0-9]+)?)`;
          const repositoryPart = String.raw`(?<repository>[a-z0-9._\/-]+)`;
          const tagPart = String.raw`(?<tag>[a-zA-Z0-9._-]+)`;
          const digestPart = String.raw`(?<digest>sha256:[a-f0-9]{64})`;
          const imageRegex = new RegExp(`^${registryPart}/${repositoryPart}:${tagPart}@${digestPart}$`);

          const tags = new Set();
          const imagesToSign = new Set();
          for(const image of images) {
            if (typeof image !== 'string'){
              return core.setFailed(`Invalid image format: ${image}. Expected a string.`);
            }

            const match = image.match(imageRegex);
            if (!match || !match.groups) {
              return core.setFailed(`Invalid image format: ${image}. Expected format: registry/name:tag@digest`);
            }

            const { registry, repository, tag, digest } = match.groups;
            tags.add(tag);

            imagesToSign.add(`${registry}/${repository}@${digest}`);
          }

          // Sign the images
          const annotationsArgs = tags.size > 0 ? `-a tag=${Array.from(tags).at(-1)}` : "";
          const imagesArgs = Array.from(imagesToSign).join(" ");
          // Use OCI 1.1 referrers mode to avoid creating legacy sha256-... tags
          // Note: If the registry doesn't support OCI 1.1 referrers (like ghcr.io currently),
          // cosign will fall back to legacy attachments and create a sha256-... tag
          const signImageCommand = `cosign sign ${annotationsArgs} --registry-referrers-mode=oci-1-1 --yes ${imagesArgs}`;

          core.debug(`Signing images with command: "${signImageCommand}"`);
          await exec.exec(signImageCommand);
          core.debug("All images signed successfully");
